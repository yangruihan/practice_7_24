Java 笔记

*Java 对大小写敏感。

* /* ... */ 注释不能嵌套，编译器只能识别一对。

* Java 整型范围
	int    4 byte  -2 147 483 647 ~ 2 147 483 647
	short  2 byte  -32 768 ~ 32 767 
	long   8 byte  -9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807
	byte   1 byte  -128 ~ 127

	long -> 4 000 000 000L(l)
	十六进制 -> 0xABC
	八进制 -> 010(十进制上的8)
	
* Java 没有任何无符号类型(unsigned type)

* Java 浮点类型范围
	float  4 byte  ≈±3.402 823 47E + 38F(有效位数为6~7位)
	double 8 byte  ≈±1.797 693 134 862 315 70E + 308(有效位数15位)

* Java 中表示溢出和出错情况的三个特殊浮点数值：
	正无穷大 Double.POSITIVE_INFINITY
	负无穷大 Double.NEGATIVE_INFINITY
	NaN(不是一个数字) Double.NaN

	@ 注意，检测一个特定值是否为非数字不能用if (x == Doule.NaN)，所有非数值的值都认为是不相同的
	只能用if (Doule.isNaN(x)) 这样的方式来检测

* Java 中，整型值与 boolean 值不能相互转化

* 以 final 定义常量

* int/0 = Exception
  double/0 = (NaN or 无穷大)

* Class Math Method:
	Math.pow(x, a) == x^a
	Math.sin()
	Math.cos()
	Math.tan()
	Math.atan()
	Math.atan2()
	Math.exp()
	Math.log()
	
	Math.PI == π
	Math.E == e

	* 在JDK5.0开始，在源文件顶部加上import static java.lang.Math.*;就可以不用添加前缀Math.

* 数值类型之间的转换
			   char
			    ↓
byte → short → int → long
                |  ↘  |
            float → double
 
	* 其中带有箭头的转换是无损精度的转换
	  | 转换是会损失一定的精度，并且long也可以转换成float，也会损失一定的精度

* double x = 9.997;
  int a = (int)x; // a == 9
  int b = (int)Math.round(x); // b == 10, Math.round返回值是long类型，故仍需要强制类型转换

* 运算符优先级
	[] . ()（方法调用）		从左向右
	! ~ ++ -- +（一元运算） -（一元运算） () （强制类型转换） new	从右向左
	* / %					从左向右
	+ -						从左向右
	<< >> >>>				从左向右
	< <= > >= instanceof	从左向右
	== !=					从左向右
	&						从左向右
	^						从左向右

	








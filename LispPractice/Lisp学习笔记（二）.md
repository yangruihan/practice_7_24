****
#Lisp学习笔记（二）
- author: Y.R.H
- time: 2015-3-11
<!--more-->

****

#(#')
- 形如：#'(evenp (...))
- 作用：获取函数，其名如下

如果没有(#')，Lisp会将 evenp（或其他）作为一个变量名对待并查找该变量的值，而不是将其看作成一个函数。

****

#(`)
- 形如：`(1 2 (+ 1 2))
- 作用：在一份反引用(`)表达式里，任何以逗号(,)开始的子表达式都是被求值的，其他的表达式一律不求值。

如：
~~~~lisp
`(1 2 (+ 1 2))  → (1 2 (+ 1 2))
`(1 2 ,(+ 1 2)) → (1 2 3)
~~~~

****

#(,@)
- 形如：`(and ,@(list 1 2 3))
- 作用：(,@)

可以将接下来的表达式（必须求值成一个列表）的值嵌入到其外围的列表里。
如：
~~~~lisp
`(and ,(list 1 2 3))    → (AND (1 2 3))
`(and ,@(list 1 2 3))   → (AND 1 2 3)
~~~~
也可以使用(,@)在列表的中间插入东西
~~~~lisp
`(and ,@(list 1 2 3) 4) → (AND 1 2 3 4)
~~~~

****

#MACROEXPAND-1函数
- 形如：(macroexpand-1 '(function-name))
- 作用：传入 macroexpand-1 一个代表宏调用的形式，它将使用适当的参数来调用宏代码并返回其展开式。

如：
~~~~lisp
CL-USER> (macroexpand-1 '(where :title "Give Us a Break" :ripped it))
#'(LAMBDA (CD)
    (AND (EQUAL (GETF CD :TITLE) "Give Us a Break")
         (EQUAL (GETF CD :RIPPED) T)))
T
~~~~

****

#S-表达式
- S-表达式的基本元素是列表(list) 和原子 (atom)。
- 注释以(;)开始，直到一行的结尾，本质上将当作空白来处理。

****

#数字
~~~~lisp
123     ; 整数一百二十三
3/7     ; 比值七分之三
1.0     ; 默认精度的浮点数一
1.0e0   ; 同一个浮点数的另一种写法
1.0d0   ; 双精度浮点数一
1.0e-4  ; 等价于万分之一的浮点数
+42     ; 整数四十二
-42     ; 整数负四十二
-1/4    ; 比值负四分之一
-2/8    ; 负四分之一的另一种写法
246/2   ; 整数一百二十三的另一种写法
~~~~

**提示：可以看出Lisp语言是不会将整个表达式存入内存，而是将计算好的值存入**

****

#字符串
- 默认跟其他语言字符串无异（以""来表示）
- 两个在字符串中必须被转义的字符是双引号和反斜杠本身。

如：
~~~~lisp
"foo"       ; 含有f、o和o的字符串
"fo\o"      ; 同一个字符串
"fo\\o"     ; 含有f、o、\和o的字符串
"fo\"o"     ; 含有f、o、"和o的字符串
~~~~

****

#名字
- 几乎任何字符都可以出现在一个名字里，不过空白字符除外，因为列表的元素是用空格来分隔的。
- 有十个字符被用于其他句法目的而不能出现在名字里，它们是：开括号和闭括号([])、双引号和单引号(""、'')、反引号(`)、逗号(,)、冒号(:)、分号(;)、反斜杠(\)以及竖线(|)。
- 而就算这些字符，如果你愿意的话，它们也能成为名字的一部分，只需将他们用反斜杠进行转义，或是将含有需要转义的字符名字用竖线包起来。
- 当读取器读取名字时，它将所有名字中未转义的字符都转化成它们等价的大写形式。如；foo、Foo和FOO都读成同一个符号：FOO
- 但是\f\o\o和|foo|都将被读成foo，是和符号FOO不同的另一个对象。
- 约定：
+   1 全局变量以(***星号****)开始和结尾，如：****global-variable**** 
+   2 常量名都以(***加号+***)开始和结尾，如：***+const-variable+***

**提醒：语言标准所定义的名字只是用字母表字符(A-Z)外加*、+、-、/、1、2、<、=、>以及&**

****

#简单的S-表达式
~~~~lisp
x                   ; 符号X
()                  ; 空列表
(1 2 3)             ; 三个数字所组成的列表
("foo" "bar")       ; 两个字符串所组成的列表
(x y z)             ; 三个符号所组成的列表
(x 1 "foo")         ; 混合列表
(+ (* 2 3) 4)       ; 由一个符号、一个列表和一个数字所组成的列表
(defun hello-world()
    (format t "hello, world"))
                    ; 由两个符号、空列表和一个列表——其本身又含两个符号和一个字符串所组成的列表
~~~~

****

#函数调用
~~~~lisp
(function-name argument*)
~~~~

****

#特殊操作符
##IF
- 形如：(if test-form then form [else-form])
+   其中test-form是条件，then-form是条件值为真时求值的表达式，else-form是条件值为假时求值的表达式。

##QUOTE
- 形如：(quote statement)
- 作用：它接受一个单一的表达式作为其“参数”并简单地返回它，不经求值。

如：
~~~~lisp
(quote (+ 1 2)) → (+ 1 2)
~~~~

**提示：由于 QUOTE 被用得十分普遍，以至于读取器中内置了一个它的特殊的语法形式：**
+   **(quote (+ 1 2)) 等价于 '(+ 1 2)**

##LET
形如：(let statement)
作用：它用来创建新的变量绑定。

如：
~~~~lisp
(let ((x 10)) x)
~~~~
+   求值得到10，因为在第二个x的求值环境中，它是由 LET 赋值为10的变量名。

****

#真、假和等价
- 符号 NIL 是唯一的假值，其他所有的都是真值。
- 符号 T 是标准的真值，可用于需要返回一个非 NIL 值却又没有其他值可用的情况。

##关于NIL
- 它是唯一一个既是原子（atom）又是列表（list）的对象，除了用来表示假以外，它还用来表示空列表。
- 因为 NIL 是一个以符号 NIL 作为其值的常值变量名，所以表达式 nil、()、'nil 以及'()求值结果是相同的
- 基于同样的道理 t 和 't 的求值结果也完全相同：符号 T 。

##四个“通用”等价谓词
###EQ
- EQ 用来测试“对象标识”，只有当两个对象相同时才是 EQ 等价的。不幸的是，数字和字符的对象标识取决于这些数据类型在特定Lisp平台上的实现的方式。因此带有相同值的两个数字或字符可能会被 EQ 认为是等价的也可能会是不等价的。

###EQL
- EQL 和 EQ 有相似的行为，除此之外，它也可以保证当相同类型的两个对象表示相同的数字或字符时，它们是等价的。
- 因此 (eql 1 1) 能确保值为真，而 (eql 1 1.0)则被确保是假，因为整数 1 和浮点数 1.0 是不同类型的对象。

###EQUAL
- EQUAL 相比 EQL 的宽松之处在于，它将在递归上具有相同结构和内容的列表视为等价。
- EQUAL 也认为含有相同字符的字符串是等价的。
- 它对于位向量和路径名也定义了比 EQL 更加宽松的等价性。

###EQUALP
- 更加宽松，并且在考察两个含有相同字符的字符串的等价性时忽略了大小写的区别。
- 它还认为如果两个字符只是大小写上有区别，那么它们就是等价的。
- 只要数字表示相同数学意义上的值，它们也是等价的。因此 (equalp 1 1.0) 值为真。
